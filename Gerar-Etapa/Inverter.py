# -*- coding: utf-8 -*-
"""
/***************************************************************************
 InverterBandeira
                                 A QGIS plugin
 Realiza inversão de bandeiras
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-13
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Igor Viana Souza
        email                : igor.souzavigor@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .Inverter_dockwidget import InverterBandeiraDockWidget
import os.path


class InverterBandeira:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'InverterBandeira_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Inverter Bandeira')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'InverterBandeira')
        self.toolbar.setObjectName(u'InverterBandeira')

        #print "** INITIALIZING InverterBandeira"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('InverterBandeira', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Inverter/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Inverter Bandeira'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING InverterBandeira"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD InverterBandeira"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Inverter Bandeira'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar
    
    
    
    def InverterBandeira(self):
        from qgis.core import QgsProcessing
        from qgis.core import QgsProcessingAlgorithm
        from qgis.core import QgsProcessingMultiStepFeedback
        from qgis.core import QgsProcessingParameterVectorLayer
        import processing
        import os # This is is needed in the pyqgis console also
        from qgis.core import (QgsVectorLayer)
        import math
        from qgis.utils import iface
        layer = iface.activeLayer()  # Get the active layer
        features = layer.selectedFeatures()  # Get the selected features

        # Check if there are at least two selected features
        if len(features) >= 2:
            # Get the first two selected features
            feature1, feature2 = features[:2]

            # Get the 'sym' values of the two features
            sym_value1 = feature1['sym']
            sym_value2 = feature2['sym']

            # Swap the values using a temporary variable
            temp = sym_value1
            sym_value1 = sym_value2
            sym_value2 = temp

            # Update the 'sym' field values of the features
            layer.startEditing()
            feature1['sym'] = sym_value1
            feature2['sym'] = sym_value2
            layer.updateFeature(feature1)
            layer.updateFeature(feature2)
            layer.commitChanges()
    
    def executar_script(self):
        from qgis.core import QgsProcessing
        from qgis.core import QgsProcessingAlgorithm
        from qgis.core import QgsProcessingMultiStepFeedback
        from qgis.core import QgsProcessingParameterVectorLayer
        import processing
        import os # This is is needed in the pyqgis console also
        from qgis.core import (QgsVectorLayer)
        import math
        from qgis.utils import iface
        dir_py = os.path.join(self.plugin_dir,'ContagemBandeiras.py')
        if self.dockwidget.checkBoxContador.isChecked():
            exec(open(dir_py).read())
        
            
            
            
    def inverter_coletados(self):
    
        from qgis.core import QgsProject
        from qgis.utils import iface
        
        layer_pt_1 = iface.activeLayer()

        # Verificar se o campo "SELECAO" existe na camada
        fieldName = 'COLETA'
        fieldIndex = layer_pt_1.fields().indexFromName(fieldName)

        if fieldIndex == -1:
            print("O campo 'COLETA' não existe na camada.")
            return

        # Percorrer todos os recursos da camada original
        layer_pt_1.startEditing()
        for feature in layer_pt_1.getFeatures():
            # Verificar se o ponto está selecionado
            if feature.id() in layer_pt_1.selectedFeatureIds():
                # Obter o valor atual do campo
                current_value = feature.attribute(fieldIndex)

                #Trocar o valor do campo
                if current_value == 'COLETADO':
                    feature.setAttribute(fieldName, 'NAO COLETADO')
                elif current_value == 'NAO COLETADO':
                    feature.setAttribute(fieldName, 'COLETADO')

                layer_pt_1.updateFeature(feature)
        layer_pt_1.commitChanges()

        print("Valores do campo 'SELECAO' trocados para os pontos selecionados.")
    
     
            
    def ComboBoxTrocaBandeiras(self):
        
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Ponto (0  a 10)':
            self.valor =  'Waypoint' 
        
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Bandeira Verde (10 a 20)':
            self.valor =  'Flag, Green'
            
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Bandeira Vermelha (20 a 40 de 0 a 10) ':
            self.valor =  'Flag, Red'    
        
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Bandeira Azul (0 a 20)':
            self.valor =  'Flag, Blue'
            
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Aviao (20 a 40 de 0 a 20)':
            self.valor =  'Airport'    
    
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Camping (40 a 60)':
            self.valor =  'Campground' 
               
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Ancora (60 a 80)':
            self.valor =  'Anchor' 
            
        if self.dockwidget.comboBoxBandeiras.currentText() == 'Mina (80 a 100)':
            self.valor =  'Mine'   
      
        
    
    def ExportarArquivos(self):
        
        self.layer = self.dockwidget.mMapLayerComboBoxAmostra.currentLayer()
        import os
        import pandas as pd
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsVectorFileWriter, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsVectorLayer
        

        self.pasta = self.dockwidget.mQgsFileWidgetPasta.filePath()
        self.etapa = self.dockwidget.lineEditEtapa.text()
        # Caminho fornecido
        self.caminho = self.pasta

        # Extrair nome "CLIENTE"
        partes = self.caminho.split('\\')
        
        self.nome_pasta1 = partes[4]
        self.nome_pasta1 = self.nome_pasta1.strip()

        # Split the string and handle the case where it doesn't contain the expected delimiter
        split_values = self.nome_pasta1.split('-')
        if len(split_values) >= 1:
            self.nome_completo = split_values[0].strip()
            if len(split_values) > 1:
                self.iniciais = split_values[1].strip()
            else:
                self.iniciais = ""  # or assign a default value

            # Rest of your code here
            # ...
        else:
            # Handle the error condition gracefully
            print("Error: Invalid string format")
        
        # Extrair nome "FAZENDA"
        self.nome_pasta2 = os.path.basename(self.caminho)
        
        amostragem = f"AMOSTRAGEM 2023 - {self.nome_completo} - FAZ {self.nome_pasta2}_ET{self.etapa}"
        titulo_resposta = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{self.etapa} - OS - BKP OU CO"
        iniciais = self.iniciais

        df = pd.DataFrame(columns=['sym', 'count'])

        def update_df(layer):
            global df
            from collections import defaultdict
            from qgis.PyQt.QtWidgets import QLabel
            from qgis.utils import iface
            import pandas as pd
            from collections import OrderedDict
            
            # Clear the previous data from the DataFrame
            df = pd.DataFrame(columns=['sym', 'count'])

            field_name = 'sym'
            total_count = layer.featureCount()
            count_waypoint = 0
            count_flag_blue = 0
            count_flag_green = 0
            count_flag_red = 0
            count_flag_airport = 0

            for feature in layer.getFeatures():
               
                
                if feature[field_name] == 'Flag, Blue':
                    count_flag_blue += 1
                if feature[field_name] == 'Airport':
                    count_flag_blue += 1
                    
                if feature[field_name] == 'Waypoint':
                    count_waypoint += 1
                
                if feature[field_name] == 'Flag, Green':
                    count_waypoint += 1
                
                if feature[field_name] == 'Flag, Red':
                    count_waypoint += 1
                
                
                
                if feature[field_name] == 'Flag, Green':
                    count_flag_green += 1
                if feature[field_name] == 'Flag, Red':
                    count_flag_green += 1
                
                if feature[field_name] == 'Flag, Red':
                    count_flag_red += 1
                
                
                if feature[field_name] == 'Airport':
                    count_flag_airport += 1
            

            # Create an empty list to store the unique sym values
            unique_syms = []

            # Loop through the features and append the unique sym values to the list
            for feature in layer.getFeatures():
                sym_value = feature['sym']
                if sym_value not in unique_syms:
                    unique_syms.append(sym_value)

            # Create a pandas DataFrame with the unique sym values and an empty count column
            df = pd.DataFrame({'sym': unique_syms, 'count': 0})

            # Update the count values based on the sym values
            #--------------------------------------------------------------------------
            

            texts = []  # Inicializa a lista vazia antes do loop
            texts = [""] * 5
            for index, row in df.iterrows():
                sym = row['sym']
                count = row['count']
                if sym == 'Waypoint':
                    texts[0] = f"PONTO: 0-10 CM ({count_waypoint} AMOSTRA(S))"
                elif sym == 'Flag, Green':
                    texts[1] = f"BANDEIRA VERDE: 0-10 + 10-20 CM ({count_flag_green} AMOSTRA(S))"
                elif sym == 'Flag, Red':
                    texts[2] = f"BANDEIRA VERMELHA: 0-10 + 10-20 + 20-40 CM ({count_flag_red} AMOSTRA(S))"
                elif sym == 'Flag, Blue':
                    texts[3] = f"BANDEIRA AZUL: 0-20 CM ({count_flag_blue} AMOSTRA(S))"
                elif sym == 'Airport':
                    texts[4] = f"AVIAO: 0-20 + 20-40 CM ({count_flag_airport} AMOSTRA(S))"

            text = '\n'.join(texts)  
            return df,text
            
            
        df, text = update_df(self.layer)
        self.saida = self.dockwidget.mQgsFileWidgetSaida.filePath()    
        file_path = self.saida +'\\'+ amostragem + ".txt"
        
        if self.dockwidget.checkBoxEtapa.isChecked() == False:
            # TXT EXPORT
            with open(file_path, "w") as arquivo:
                arquivo.write(f"AMOSTRAGEM: {amostragem}\n")
                arquivo.write(f"TITULO PARA RESPOSTA: {titulo_resposta}\n")
                arquivo.write(f"INICIAIS: {iniciais}\n")
                arquivo.write("\n")
                arquivo.write(text)
                arquivo.write("\n")
                arquivo.write("ESCREVER O NOME DA OS, CLIENTE E FAZENDA NO SACO")
            
            titulo_arquivo = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{self.etapa}"
            path_etapa = self.saida +'\\' + titulo_arquivo + ".gpx"
            
            # GPX EXPORT
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.ct = QgsCoordinateTransform(self.layer.crs(), QgsCoordinateReferenceSystem(4326), QgsProject.instance())
            options.driverName = "GPX"
            options.datasourceOptions = ["GPX_USE_EXTENSIONS=ON"]
            options.fileEncoding = "utf-8"
            options.layerOptions = ["FORCE_GPX_ROUTE=YES"]
            result= QgsVectorFileWriter.writeAsVectorFormatV2(self.layer,path_etapa,self.layer.transformContext(),options)
        else:
            field_name = 'COLETA'
            self.layer = self.dockwidget.mMapLayerComboBoxAmostra.currentLayer()
            layer_number = int(self.layer.name())
            filter_expression = f'"{field_name}" = \'NAO COLETADO\''
            self.layer.setSubsetString(filter_expression)
            df = pd.DataFrame(columns=['sym', 'count'])
            self.etapa = self.dockwidget.lineEditEtapa.text()
            titulo_proxima_etapa = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{str(layer_number + 1)}"
            amostragem_proxima_etapa = f"AMOSTRAGEM 2023 - {self.nome_completo} - FAZ {self.nome_pasta2}_ET{str(layer_number + 1)}"
            
            def update_df(layer):
                global df
                from collections import defaultdict
                from qgis.PyQt.QtWidgets import QLabel
                from qgis.utils import iface
                import pandas as pd
                from collections import OrderedDict
                # Clear the previous data from the DataFrame
                df = pd.DataFrame(columns=['sym', 'count'])

                field_name = 'sym'
                total_count = layer.featureCount()
                count_waypoint = 0
                count_flag_blue = 0
                count_flag_green = 0
                count_flag_red = 0
                count_flag_airport = 0

                for feature in layer.getFeatures():
                   
                    
                    if feature[field_name] == 'Flag, Blue':
                        count_flag_blue += 1
                    if feature[field_name] == 'Airport':
                        count_flag_blue += 1
                        
                    if feature[field_name] == 'Waypoint':
                        count_waypoint += 1
                    
                    if feature[field_name] == 'Flag, Green':
                        count_waypoint += 1
                    
                    if feature[field_name] == 'Flag, Red':
                        count_waypoint += 1
                    
                    
                    
                    if feature[field_name] == 'Flag, Green':
                        count_flag_green += 1
                    if feature[field_name] == 'Flag, Red':
                        count_flag_green += 1
                    
                    if feature[field_name] == 'Flag, Red':
                        count_flag_red += 1
                    
                    
                    if feature[field_name] == 'Airport':
                        count_flag_airport += 1
                

                # Create an empty list to store the unique sym values
                unique_syms = []

                # Loop through the features and append the unique sym values to the list
                for feature in layer.getFeatures():
                    sym_value = feature['sym']
                    if sym_value not in unique_syms:
                        unique_syms.append(sym_value)

                # Create a pandas DataFrame with the unique sym values and an empty count column
                df = pd.DataFrame({'sym': unique_syms, 'count': 0})

                # Update the count values based on the sym values
                #--------------------------------------------------------------------------
                

                texts = []  # Inicializa a lista vazia antes do loop
                texts = [""] * 5
                for index, row in df.iterrows():
                    sym = row['sym']
                    count = row['count']
                    if sym == 'Waypoint':
                        texts[0] = f"PONTO: 0-10 CM ({count_waypoint} AMOSTRA(S))"
                    elif sym == 'Flag, Green':
                        texts[1] = f"BANDEIRA VERDE: 0-10 + 10-20 CM ({count_flag_green} AMOSTRA(S))"
                    elif sym == 'Flag, Red':
                        texts[2] = f"BANDEIRA VERMELHA: 0-10 + 10-20 + 20-40 CM ({count_flag_red} AMOSTRA(S))"
                    elif sym == 'Flag, Blue':
                        texts[3] = f"BANDEIRA AZUL: 0-20 CM ({count_flag_blue} AMOSTRA(S))"
                    elif sym == 'Airport':
                        texts[4] = f"AVIAO: 0-20 + 20-40 CM ({count_flag_airport} AMOSTRA(S))"

                text = '\n'.join(texts)  
                return df,text
                
                
            df, text = update_df(self.layer)
            file_path_proxima_etapa = self.saida +'\\'+ amostragem_proxima_etapa + ".txt"
                
            with open(file_path_proxima_etapa, "w") as arquivo:
                arquivo.write(f"AMOSTRAGEM: {amostragem_proxima_etapa}\n")
                arquivo.write(f"TITULO PARA RESPOSTA: {titulo_proxima_etapa} - OS - BKP OU CO\n")

                arquivo.write(f"INICIAIS: {iniciais}\n")
                arquivo.write("\n")
               
                arquivo.write(text)
                arquivo.write("\n")
                arquivo.write("ESCREVER O NOME DA OS, CLIENTE E FAZENDA NO SACO")

            self.layer.setSubsetString('')
            
        

        
            # Pegando Caminhos
            self.layer = self.dockwidget.mMapLayerComboBoxAmostra.currentLayer()
            self.pasta = self.dockwidget.mQgsFileWidgetPasta.filePath()
            self.etapa = self.dockwidget.lineEditEtapa.text()
            self.saida = self.dockwidget.mQgsFileWidgetSaida.filePath()    
            
            
            # Caminho fornecido
            self.caminho = self.pasta

            # Extrair nome "CLIENTE"
            partes = self.caminho.split('\\')
            
            self.nome_pasta1 = partes[4]
            self.nome_pasta1 = self.nome_pasta1.strip()

            # Split the string and handle the case where it doesn't contain the expected delimiter
            split_values = self.nome_pasta1.split('-')
            if len(split_values) >= 1:
                self.nome_completo = split_values[0].strip()
                if len(split_values) > 1:
                    self.iniciais = split_values[1].strip()
                else:
                    self.iniciais = ""  # or assign a default value

                # Rest of your code here
                # ...
            else:
                # Handle the error condition gracefully
                print("Error: Invalid string format")
            
            # Extrair nome "FAZENDA"
            self.nome_pasta2 = os.path.basename(self.caminho)
            
            amostragem = f"AMOSTRAGEM 2023 - {self.nome_completo} - FAZ {self.nome_pasta2}_ET{self.etapa}"
            titulo_resposta = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{self.etapa} - OS - BKP OU CO"
            iniciais = self.iniciais
            titulo_arquivo = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{self.etapa}"
            
            layer = self.dockwidget.mMapLayerComboBoxAmostra.currentLayer()
            
            field_name = "COLETA"  # Substitua pelo nome do campo desejado
            
            caminho_salvar = self.dockwidget.mQgsFileWidgetPasta.filePath()
            # Obtendo o número da layer
            layer_number = int(layer.name())

            # Definindo os nomes dos arquivos de saída
            titulo_feito = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{str(layer_number)}_FEITO"
            titulo_proxima_etapa = f"{self.nome_completo} - FAZ {self.nome_pasta2}_ET{str(layer_number + 1)}"
            
            file_path = self.saida +'\\'+ amostragem + ".txt"
            path_etapa = self.saida +'\\' + titulo_arquivo + ".gpx"
          

            # Caminhos para salvar os arquivos GPX
            path_coletado = self.saida +'\\' + titulo_feito + ".gpx"
            path_nao_coletado = self.saida +'\\' + titulo_proxima_etapa + ".gpx"
            
            
            path_shp_nao_coletado = "/vsimem/" + titulo_proxima_etapa + ".shp"

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.ct = QgsCoordinateTransform(layer.crs(), QgsCoordinateReferenceSystem(4326), QgsProject.instance())
            options.driverName = "GPX"
            options.datasourceOptions = ["GPX_USE_EXTENSIONS=ON"]
            options.fileEncoding = "utf-8"
            options.layerOptions = ["FORCE_GPX_ROUTE=YES"]
            options.onlySelectedFeatures = True

            # Filtrar apenas as feições com o valor desejado no campo "COLETA"
            layer.selectByExpression(f'"{field_name}" = \'COLETADO\'', QgsVectorLayer.SetSelection)

            result = QgsVectorFileWriter.writeAsVectorFormatV2(
                layer,
                path_coletado,
                layer.transformContext(),
                options)
                
            # Filtrar apenas as feições com o valor desejado no campo "COLETA"
            layer.selectByExpression(f'"{field_name}" = \'NAO COLETADO\'', QgsVectorLayer.SetSelection)

            result = QgsVectorFileWriter.writeAsVectorFormatV2(
                layer,
                path_nao_coletado,
                layer.transformContext(),
                options)
            

            # Definir expressão de filtro para selecionar apenas as feições "NAO COLETADO"
            filter_expression = f'"{field_name}" = \'NAO COLETADO\''
            layer.setSubsetString(filter_expression)

            # Salvar a camada como um arquivo shapefile permanente
            # Atribuir a projeção correta para a camada
            crs = QgsCoordinateReferenceSystem("EPSG:4326")
            layer.setCrs(crs)
            
            if QgsVectorFileWriter.writeAsVectorFormat(layer, path_shp_nao_coletado, "utf-8", crs, "ESRI Shapefile"):
                print("Arquivo SHP de solo feito criado com sucesso.")
            else:
                print("Falha ao criar o arquivo SHP de solo feito.")
               
            layer.setSubsetString('')
        
           
    def handleCheckboxStateChange(self):
        
        if self.dockwidget.checkBoxEtapa.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
           
            self.dockwidget.lineEditEtapa.setEnabled(False)
        else:
            self.dockwidget.lineEditEtapa.setEnabled(True)
        
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING InverterBandeira"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = InverterBandeiraDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
            
            self.dockwidget.pushButtonInverterBandeira.clicked.connect(self.InverterBandeira)
            
            
            
            
       
            
            
            self.dockwidget.checkBoxEtapa.stateChanged.connect(self.handleCheckboxStateChange)
            self.dockwidget.pushButtonColetado.clicked.connect(self.inverter_coletados)
            self.dockwidget.checkBoxContador.stateChanged.connect(self.executar_script)
            self.dockwidget.pushButtonTrocarBandeira.clicked.connect(self.TrocarBandeira)
            self.dockwidget.pushButtonMesclar.clicked.connect(self.MesclarAmostras)
            self.dockwidget.pushButtonExportar.clicked.connect(self.ExportarArquivos)
            
    def TrocarBandeira(self):
        from qgis.utils import iface
        self.ComboBoxTrocaBandeiras()
        self.novo_valor = self.valor
        layer = iface.activeLayer()
        def TrocarBandeira():
                
        
            field_name = 'sym'  # Nome do campo a ser atualizado

            if layer.selectedFeatureCount() > 0:
                features = layer.selectedFeatures()  # Obtém as features selecionadas

                layer.startEditing()  # Inicia a edição do layer

                for feature in features:
                    feature[field_name] = self.novo_valor  # Substitua 'novo_valor' pelo valor que deseja atribuir ao campo 'sym'
                    layer.updateFeature(feature)  # Atualiza a feature no layer

                layer.commitChanges() 
        TrocarBandeira()
    def MesclarAmostras(self):
        

        def Mesclar():
            from qgis.core import QgsProcessing
            from qgis.core import QgsProcessingAlgorithm
            from qgis.core import QgsProcessingMultiStepFeedback
            from qgis.core import QgsProcessingParameterVectorLayer
            from qgis.core import QgsProject
            import processing
            # MESCLANDO 
            selected_layers = QgsProject.instance().layerTreeRoot().findLayers()
            
            if len(selected_layers) < 2:
                return None  # Return None if less than 2 layers are selected
            
            layer_names = [layer.name() for layer in selected_layers]
            
            mesclado = processing.run('native:mergevectorlayers', {
                'CRS': None,
                'LAYERS': layer_names,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            })
            
            output_mesclagem = mesclado['OUTPUT']
            QgsProject.instance().addMapLayer(output_mesclagem)
            old_name=QgsProject.instance().mapLayersByName("Mesclado")[0] 
            old_name.setName("AMOSTRAS ESTRATIFICADAS")
            output_mesclagem.loadNamedStyle(os.path.join(self.plugin_dir,'legenda_gps13.qml'))
            output_mesclagem.triggerRepaint()
            return output_mesclagem
    
        Mesclar()
        
   