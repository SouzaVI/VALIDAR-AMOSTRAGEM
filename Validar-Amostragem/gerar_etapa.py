# -*- coding: utf-8 -*-
"""
/***************************************************************************
 gerar_etapa
                                 A QGIS plugin
 Este plugin ira gerar a etapa feito e a proxima etapa caso necessario
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Helio Antonio de Olivera Junior \ TERRAM
        email                : helio.engflorestal@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from .resources import *

from qgis.core import *
from qgis.gui import *
from PyQt5.QtCore import Qt
import processing
from osgeo import ogr, osr
import pandas as pd
import geopandas as gpd
import pandas as pd
from shapely.geometry import Point
import fiona
from qgis.utils import iface
from qgis.core import (
    QgsProject,
    QgsVectorFileWriter,
    QgsCoordinateReferenceSystem,
    QgsVectorLayer,
)
import xml.etree.ElementTree as ET
import os

# Import the code for the DockWidget
from .gerar_etapa_dockwidget import gerar_etapaDockWidget
import os.path


class gerar_etapa:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'gerar_etapa_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Gerar Etapa')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'gerar_etapa')
        self.toolbar.setObjectName(u'gerar_etapa')

        #print "** INITIALIZING gerar_etapa"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('gerar_etapa', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gerar_etapa/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'gerar_etapa'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------
                
    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING gerar_etapa"
        
        self.dockwidget.pushButton_IMPORTA_TRJ.clicked.disconnect(self.gpx_shp_TRJ)
        self.dockwidget.ORGANIZAR_EXCEL.clicked.disconnect(self.selecionar_arquivos_concatenar)
        self.dockwidget.IMPORTAR_ETAPA.clicked.disconnect(self.gpx_shp_solo_feito)
        self.dockwidget.SELECAO_PONTOS.clicked.disconnect(self.selecionar_pontos)
        self.dockwidget.pushButton_INVERTER_COLETA.clicked.disconnect(self.inverter_coletados)


        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD gerar_etapa"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Gerar Etapa'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    
    def gpx_shp_TRJ(self):
        import os
        from osgeo import ogr
        from qgis.core import QgsVectorLayer, QgsCoordinateReferenceSystem
        from qgis import processing
        from PyQt5.QtWidgets import QFileDialog
        
        # Abra a caixa de diálogo de seleção de arquivos GPX
        file_dialog = QFileDialog()
        file_dialog.setFileMode(QFileDialog.ExistingFiles)
        file_dialog.setNameFilter("GPX Files (*.gpx)")
        
        
        if file_dialog.exec_():
            # Obtenha a lista de arquivos GPX selecionados
            input_gpx_files = file_dialog.selectedFiles()
            
            for input_gpx_file in input_gpx_files:
                # Defina o nome do arquivo SHP de saída com base no nome do arquivo GPX
                
                output_shapefile = '/vsimem/' + os.path.splitext(input_gpx_file)[0] + '.shp'
                
                # Crie um objeto de driver OGR para o formato GPX
                gpx_driver = ogr.GetDriverByName("GPX")

                # Abra o arquivo GPX de entrada e crie um objeto de camada OGR
                gpx_data_source = gpx_driver.Open(input_gpx_file, 0)
                gpx_layer = gpx_data_source.GetLayer("tracks")

                # Crie um objeto de driver OGR para o formato SHP
                shp_driver = ogr.GetDriverByName("ESRI Shapefile")

                # Crie o arquivo SHP de saída
                if os.path.exists(output_shapefile):
                    shp_driver.DeleteDataSource(output_shapefile)
                shp_data_source = shp_driver.CreateDataSource(output_shapefile)

                # Crie uma nova camada no arquivo SHP de saída
                shp_layer = shp_data_source.CreateLayer("temp", None, ogr.wkbLineString)

                # Defina os campos da camada
                field_def_name = ogr.FieldDefn("name", ogr.OFTString)
                field_def_name.SetWidth(50)
                shp_layer.CreateField(field_def_name)     

                # Copie as feições da camada GPX de entrada para a camada SHP de saída
                for gpx_feature in gpx_layer:
                    shp_feature = ogr.Feature(shp_layer.GetLayerDefn())
                    shp_feature.SetGeometry(gpx_feature.GetGeometryRef())
                    shp_feature.SetField("name", gpx_feature.GetField("name"))
                    shp_layer.CreateFeature(shp_feature)

                # Feche os arquivos de dados
                gpx_data_source = None
                shp_data_source = None

                # Adicione a camada SHP de saída ao QGIS
                self.iface.addVectorLayer(output_shapefile, os.path.splitext(os.path.basename(output_shapefile))[0], "ogr")


    def organizar_excel(self, file_path):
        import pandas as pd
        from PyQt5.QtWidgets import QFileDialog

        # Load the Excel file
        dados_excel = pd.read_excel(file_path, header=None, engine='openpyxl')

        # Criar DataFrame com as informações até a linha 5
        df_ate_5 = dados_excel.iloc[:5]

        # Criar DataFrame com as informações a partir da linha 10
        df_a_partir_10 = dados_excel.iloc[10:]
        df_a_partir_10 = df_a_partir_10.drop(2, axis=1)  # Excluir a coluna 2

        # Obter o valor da primeira linha e primeira coluna da df_ate_5
        nome_assistente = df_ate_5.iloc[0, 1]
        OS = df_ate_5.iloc[3, 1]

        # Extrair a parte inicial do nome do arquivo
        nome_arquivo = file_path.split("/")[-1]
        partes_nome = nome_arquivo.split("-")
        parte_inicial = "-".join(partes_nome[:-1]).strip()

        # Filtrar as linhas onde o ID não está vazio
        df_a_partir_10 = df_a_partir_10[df_a_partir_10.iloc[:, 0].notna()]

        # Criar um novo DataFrame com as colunas desejadas
        novo_df = pd.DataFrame({
            "PONTO_GPS": df_a_partir_10.iloc[:, 0],
            "OBSERVAÇÃO": df_a_partir_10.iloc[:, 1],
            "NOME DO ASSISTENTE TÉCNICO": nome_assistente,
            "OS": OS
        })

        return novo_df, parte_inicial


    def selecionar_arquivos_concatenar(self):
        import pandas as pd
        from PyQt5.QtWidgets import QFileDialog
        import os
        from PyQt5.QtWidgets import QInputDialog, QMessageBox

        # Open a file dialog to select multiple files
        file_dialog = QFileDialog()
        file_dialog.setFileMode(QFileDialog.ExistingFiles)
        file_dialog.setNameFilter("Excel Files (*.xlsx)")
        if file_dialog.exec_():
            file_paths = file_dialog.selectedFiles()

            # Check if at least one file is selected
            if len(file_paths) > 0:
                # Create an empty DataFrame to store concatenated data
                concatenated_data = pd.DataFrame()

                # Concatenate data from each Excel file
                for file_path in file_paths:
                    # Organize the Excel file and get the desired DataFrame
                    novo_df, parte_inicial = self.organizar_excel(file_path)

                    # Append the data to the concatenated_data DataFrame
                    concatenated_data = pd.concat([concatenated_data, novo_df])

                # Save the concatenated data to a new Excel file
                nome_arquivo = os.path.basename(file_paths[0])
                nome_arquivo_sem_extensao = os.path.splitext(nome_arquivo)[0]
                diretorio_salvar_arquivo = os.path.dirname(file_paths[0])
                novo_nome_arquivo = "organizado_" + parte_inicial
                caminho_arquivo_salvar = os.path.join(diretorio_salvar_arquivo, novo_nome_arquivo + ".xlsx")

                # Exportar o DataFrame concatenado para um arquivo Excel
                concatenated_data.to_excel(caminho_arquivo_salvar, index=False, engine='openpyxl')
                
                # Exibir mensagem de sucesso em uma caixa de diálogo
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Informação")
        msg_box.setText("ARQUIVOS ORGANIZADOS")
        msg_box.exec_()
 
    def gpx_shp_CO(self,input_gpx_file):
        import os
        from osgeo import ogr
        from qgis.core import QgsVectorLayer, QgsCoordinateReferenceSystem
        from qgis import processing
        from PyQt5.QtWidgets import QFileDialog

        output_shapefile = '/vsimem/' + os.path.splitext(input_gpx_file)[0] + '.shp'

        # Crie um objeto de driver OGR para o formato GPX
        gpx_driver = ogr.GetDriverByName("GPX")

        # Abra o arquivo GPX de entrada e crie um objeto de camada OGR
        gpx_data_source = gpx_driver.Open(input_gpx_file, 0)
        gpx_layer = gpx_data_source.GetLayer("tracks")

        # Crie um objeto de driver OGR para o formato SHP
        shp_driver = ogr.GetDriverByName("ESRI Shapefile")

        # Crie o arquivo SHP de saída
        if os.path.exists(output_shapefile):
            shp_driver.DeleteDataSource(output_shapefile)
        shp_data_source = shp_driver.CreateDataSource(output_shapefile)

        # Crie uma nova camada no arquivo SHP de saída
        shp_layer = shp_data_source.CreateLayer("temp", None, ogr.wkbLineString)

        # Defina os campos da camada
        field_def_name = ogr.FieldDefn("name", ogr.OFTString)
        field_def_name.SetWidth(50)
        shp_layer.CreateField(field_def_name)     

        # Copie as feições da camada GPX de entrada para a camada SHP de saída
        for gpx_feature in gpx_layer:
            shp_feature = ogr.Feature(shp_layer.GetLayerDefn())
            shp_feature.SetGeometry(gpx_feature.GetGeometryRef())
            shp_feature.SetField("name", gpx_feature.GetField("name"))
            shp_layer.CreateFeature(shp_feature)

        # Feche os arquivos de dados
        gpx_data_source = None
        shp_data_source = None

        # Adicione a camada SHP de saída ao QGIS
        layer=self.iface.addVectorLayer(output_shapefile, os.path.splitext(os.path.basename(output_shapefile))[0], "ogr")
    
        layer.loadNamedStyle(os.path.join(self.plugin_dir,'estilo_contorno_gpx.qml'))
        layer.triggerRepaint()
        
    def gpx_shp_solo_feito(self):
        import os
        from osgeo import ogr
        from qgis.core import (
            QgsVectorLayer,
            QgsCoordinateReferenceSystem,
            QgsField,
            QgsProject,
            QgsVectorFileWriter,
        )
        from PyQt5.QtCore import QVariant
        from PyQt5.QtWidgets import QFileDialog
        import re

        # Abra a caixa de diálogo de seleção de arquivo GPX
        file_dialog = QFileDialog()
        file_dialog.setFileMode(QFileDialog.ExistingFile)
        file_dialog.setNameFilter("GPX Files (*.gpx)")

        if file_dialog.exec_():
            # Obtenha o caminho do arquivo GPX selecionado
            input_gpx_file = file_dialog.selectedFiles()[0]
            
            self.gpx_shp_CO(input_gpx_file)

            # Caminho do arquivo SHP de saída temporário
            output_shapefile = '/vsimem/temp.shp'

            # Crie um objeto de driver OGR para o formato GPX
            gpx_driver = ogr.GetDriverByName("GPX")

            # Abra o arquivo GPX de entrada e crie um objeto de camada OGR
            gpx_data_source = gpx_driver.Open(input_gpx_file, 0)
            gpx_layer = gpx_data_source.GetLayer("Waypoints")

            # Crie um objeto de driver OGR para o formato SHP
            shp_driver = ogr.GetDriverByName("ESRI Shapefile")

            # Crie o arquivo SHP temporário
            if os.path.exists(output_shapefile):
                shp_driver.DeleteDataSource(output_shapefile)
            shp_data_source = shp_driver.CreateDataSource(output_shapefile)

            # Crie uma nova camada no arquivo SHP temporário
            shp_layer = shp_data_source.CreateLayer("temp", None, ogr.wkbPoint)

            # Defina os campos da camada
            field_def_name = ogr.FieldDefn("name", ogr.OFTString)
            field_def_name.SetWidth(50)
            shp_layer.CreateField(field_def_name)

            field_def_cmt = ogr.FieldDefn("cmt", ogr.OFTString)
            field_def_cmt.SetWidth(10)
            shp_layer.CreateField(field_def_cmt)

            field_def_desc = ogr.FieldDefn("desc", ogr.OFTString)
            field_def_desc.SetWidth(10)
            shp_layer.CreateField(field_def_desc)

            field_def_sym = ogr.FieldDefn("sym", ogr.OFTString)
            field_def_sym.SetWidth(10)
            shp_layer.CreateField(field_def_sym)

            # Copie as feições da camada GPX de entrada para a camada SHP temporária
            for gpx_feature in gpx_layer:
                shp_feature = ogr.Feature(shp_layer.GetLayerDefn())
                shp_feature.SetGeometry(gpx_feature.GetGeometryRef())
                shp_feature.SetField("name", gpx_feature.GetField("name"))
                shp_feature.SetField("cmt", gpx_feature.GetField("cmt"))
                shp_feature.SetField("desc", gpx_feature.GetField("desc"))
                shp_feature.SetField("sym", gpx_feature.GetField("sym"))
                shp_layer.CreateFeature(shp_feature)
                shp_feature = None

            # Feche os arquivos de dados
            gpx_data_source = None
            shp_data_source = None
            
            # Extrair o nome do arquivo sem o caminho e a extensão
            nome_arquivo = os.path.splitext(os.path.basename(input_gpx_file))[0]
            match = re.search(r'ET(\d+)', nome_arquivo)

            if match:
                numero_et = match.group(1)
            else:
                print("Número ET não encontrado no nome do arquivo.")
                return
            # Carregue o arquivo SHP temporário como uma camada vetor no QGIS
            layer = QgsVectorLayer(output_shapefile, numero_et, "ogr")
            if not layer.isValid():
                print("Falha ao carregar o arquivo SHP.")
                return
            
            # Atribua a projeção correta para a camada
            crs = QgsCoordinateReferenceSystem("EPSG:4326")
            layer.setCrs(crs)

            # Salve a camada como um arquivo SHP permanente
            output_shp_solo_feito = '/vsimem/temp_of.shp'
            if QgsVectorFileWriter.writeAsVectorFormat(layer, output_shp_solo_feito, "utf-8", crs, "ESRI Shapefile"):
                print("Arquivo SHP de solo feito criado com sucesso.")
            else:
                print("Falha ao criar o arquivo SHP de solo feito.")
                
            # Load the permanent SHP layer as a QgsVectorLayer
            output_layer = QgsVectorLayer(output_shp_solo_feito, numero_et, "ogr")
            if output_layer.isValid():
                # Access the data provider and fields of the output layer
                provider = output_layer.dataProvider()
                fields = provider.fields()

                # Create fields for "COLETA", "AT", and "OS" if they don't exist
                campos = ['COLETA', 'OS', 'AT', 'OBSERVACAO']
                for campo in campos:
                    indice_campo = fields.indexFromName(campo)
                    if indice_campo == -1:
                        novo_campo = QgsField(campo, QVariant.String)
                        provider.addAttributes([novo_campo])
                        output_layer.updateFields()
            else:
                print("Falha ao carregar o arquivo SHP permanente.")

            # Carregue a camada SHP permanente como uma camada vetor no QGIS
            output_layer = QgsVectorLayer(output_shp_solo_feito, numero_et, "ogr")
            if output_layer.isValid():
                # Adicione a camada ao projeto do QGIS
                QgsProject.instance().addMapLayer(output_layer)

                # Atualize o mapa para mostrar a camada
                iface.mapCanvas().refresh()
            else:
                print("Falha ao carregar o arquivo SHP permanente.")
    
    def selecionar_pontos(self):
        import pandas as pd
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsRendererCategory, QgsCategorizedSymbolRenderer
        from qgis.core import QgsFeature, QgsField, QgsFields, QgsVectorLayer, QgsGeometry
        import numpy as np

        # Caminho para o arquivo Excel
        caminho_excel = self.dockwidget.ENTRADA_EXCEL.filePath()

        if caminho_excel is not None:
            # Nome da camada no QGIS
            nome_camada = self.dockwidget.mMapLayerComboBox_PONTOS

        # Nome do campo ID no shapefile
        nome_campo_id_shape = 'name'

        # Nome do campo "COLETADO" no shapefile
        nome_campo_coletado = 'COLETA'

        # Carregar o arquivo Excel utilizando a biblioteca pandas
        dados_excel = pd.read_excel(caminho_excel, engine='openpyxl')

        # Handle empty values in OBSERVACAO column
        dados_excel['OBSERVAÇÃO'].fillna('', inplace=True)
        # Obter os IDs do arquivo Excel
        ids = dados_excel['PONTO_GPS'].astype(str).tolist()
        os_values = dados_excel['OS'].tolist()
        at_values = dados_excel['NOME DO ASSISTENTE TÉCNICO'].tolist()
        observacao_values = dados_excel['OBSERVAÇÃO'].tolist()
        # Obter a camada do QGIS pelo nome
        camada = nome_camada.currentLayer()

        # Criar uma expressão de seleção com base nos IDs
        expressao_selecao = f'"{nome_campo_id_shape}" IN ({",".join(map(str, ids))})'

        # Limpar qualquer seleção anterior
        camada.removeSelection()

        # Selecionar os pontos com base na expressão
        camada.selectByExpression(expressao_selecao, QgsVectorLayer.SetSelection)

        # Atualizar o mapa para mostrar a seleção
        iface.mapCanvas().refresh()

        # Percorrer todos os recursos da camada original
        camada.startEditing()
        for feature in camada.getFeatures():
            # Verificar se o ponto está selecionado
            if str(feature[nome_campo_id_shape]) in ids:
                # Obter o índice correspondente do valor de "PONTO_GPS" no shapefile
                index = ids.index(str(feature[nome_campo_id_shape]))
                # Obter os valores de "AT" e "OS" correspondentes
                at_value = at_values[index]
                os_value = os_values[index]
                observacao_value = observacao_values[index]
                
                # Handle NaN values in observacao_value
                if isinstance(observacao_value, float) and np.isnan(observacao_value):
                    observacao_value = ""  # Replace NaN with an empty string
            
                # Atualizar os valores dos campos "AT" e "OS" no shapefile
                feature.setAttribute('AT', at_value)
                feature.setAttribute('OS', os_value)

                
                # Atualizar o valor do campo "OBSERVACAO" para o valor correspondente, ou vazio se for None
                if observacao_value is not None:
                    feature.setAttribute('OBSERVACAO', observacao_value)
                else:
                    feature.setAttribute('OBSERVACAO', "")
                # Atualizar o valor do campo "COLETADO" para "COLETADO"
                feature.setAttribute(nome_campo_coletado, 'COLETADO')
            else:
                # Atualizar o valor do campo "COLETADO" para "NÃO COLETADO"
                feature.setAttribute(nome_campo_coletado, 'NAO COLETADO')
            camada.updateFeature(feature)
            print(f"Feature ID: {feature.id()} - {nome_campo_id_shape}: {feature[nome_campo_id_shape]} - Attributes: {feature.attributes()}")
        camada.commitChanges()

        # Carregar o estilo padrão para a camada
        camada.loadNamedStyle(os.path.join(self.plugin_dir,'estilo_pontos_V1.qml'))
        camada.triggerRepaint()
        
        
        
        
        ##ATUALIZAR A CAMADA POR COR
        
        # Obtenha a camada desejada pelo nome
 
        layer = camada

        # Verifique se a camada tem um campo 'numero_os'
        if 'OS' in layer.fields().names():
            unique_os_numbers = set()
            feature_count = layer.featureCount()

            # Obtenha todos os números de OS únicos
            for feature in layer.getFeatures():
                unique_os_numbers.add(feature['OS'])

            # Crie um objeto QgsCategorizedSymbolRenderer para atribuir cores aos números de OS
            renderer = QgsCategorizedSymbolRenderer('OS')

            # Crie uma categoria de cor para cada número de OS único
            for os_number in unique_os_numbers:
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                category = QgsRendererCategory(os_number, symbol, str(os_number))
                renderer.addCategory(category)

            # Defina o QgsCategorizedSymbolRenderer para a camada
            layer.setRenderer(renderer)

            # Atualize o renderizador e repinte a camada
            layer.triggerRepaint()

            # Salve as alterações no projeto
            QgsProject.instance().write()
            
        ## CRIAR A ESTATISTICA
        
        existing_layers = QgsProject.instance().mapLayersByName('ESTATISTICA OS')
        if existing_layers:
            QgsProject.instance().removeMapLayers([l.id() for l in existing_layers])

    
        estatistica = processing.run('qgis:statisticsbycategories', {
            'CATEGORIES_FIELD_NAME': ['OS'],
            'INPUT': camada,
            'OUTPUT':'TEMPORARY_OUTPUT',
            'VALUES_FIELD_NAME': ''            
        })
        output = estatistica['OUTPUT']  # Aqui, "output" é a camada de estatística criada
        output.setName('ESTATISTICA OS')  # Definimos o nome da camada de estatística
        QgsProject.instance().addMapLayer(output)
        
        ## CRIAR A ESTATISTICA
        existing_layers = QgsProject.instance().mapLayersByName('ESTATISTICA OBSERVAÇÃO')
        if existing_layers:
            QgsProject.instance().removeMapLayers([l.id() for l in existing_layers])
        
        # Verifica se o campo de observação não é nulo (vazio) em geral
        field_name = 'OBSERVACAO'  # Substitua 'OBSERVACAO' pelo nome do campo de observação
        field_index = camada.fields().indexFromName(field_name)

        non_null_categories = set()  # Armazena as categorias não nulas únicas
        for feature in camada.getFeatures():
            value = feature[field_index]
            if value is not None:
                non_null_categories.add(value)

        if len(non_null_categories) > 1:
            estatistica = processing.run('qgis:statisticsbycategories', {
                'CATEGORIES_FIELD_NAME': [field_name],
                'INPUT': camada,
                'OUTPUT': 'TEMPORARY_OUTPUT',
                'VALUES_FIELD_NAME': '',
                'INCLUDE_NULL_VALUES': False  # Configura para não incluir valores nulos (vazios) na estatística
            })

            # Verifica se a soma (contagem) é maior que 1 na observação, ignorando valores vazios
            sum_field_name = 'count'  # Substitua 'count' pelo nome do campo de contagem retornado na estatística (verifique o nome correto na saída)
            for stat_feature in estatistica['OUTPUT'].getFeatures():
                if stat_feature[sum_field_name] and stat_feature[sum_field_name] > 1:
                    # Renomeia o nome do arquivo temporário para 'ESTATISTICVA_OBSERVAÇÃO'
                    estatistica['OUTPUT'].setName('ESTATISTICA OBSERVAÇÃO')
                    QgsProject.instance().addMapLayer(estatistica['OUTPUT'])
                    break


    def inverter_coletados(self):

        from qgis.core import QgsProject
        from qgis.utils import iface
        from PyQt5.QtWidgets import QInputDialog, QMessageBox

        layer_pt_1 = iface.activeLayer()

        # Verificar se o campo "SELECAO" existe na camada
        fieldName = 'COLETA'
        fieldIndex = layer_pt_1.fields().indexFromName(fieldName)

        if fieldIndex == -1:
            print("O campo 'COLETA' não existe na camada.")
            return

        # Percorrer todos os recursos da camada original
        layer_pt_1.startEditing()

        # Abrir caixa de diálogo para inserir o número da OS
        

        for feature in layer_pt_1.getFeatures():
            # Verificar se o ponto está selecionado
            if feature.id() in layer_pt_1.selectedFeatureIds():
                # Obter o valor atual do campo
                current_value = feature.attribute(fieldIndex)

                # Trocar o valor do campo
                if current_value == 'COLETADO':
                    feature.setAttribute(fieldName, 'NAO COLETADO')
                    feature.setAttribute('OS', '')
                    feature.setAttribute('At', '')
                    feature.setAttribute('OBSERVACAO', '')
                elif current_value == 'NAO COLETADO':
                    feature.setAttribute(fieldName, 'COLETADO')
                    os_number=self.dockwidget.mLineEdit_os.text()
                    # Definir o número da OS no atributo 'OS' do recurso
                    feature.setAttribute('OS', os_number)

                layer_pt_1.updateFeature(feature)
        layer_pt_1.commitChanges()
        
        existing_layers = QgsProject.instance().mapLayersByName('ESTATISTICA OS')
        if existing_layers:
            QgsProject.instance().removeMapLayers([l.id() for l in existing_layers])

        
        estatistica = processing.run('qgis:statisticsbycategories', {
            'CATEGORIES_FIELD_NAME': ['OS'],
            'INPUT': layer_pt_1,
            'OUTPUT':'TEMPORARY_OUTPUT',
            'VALUES_FIELD_NAME': ''            
        })
        output = estatistica['OUTPUT']  # Aqui, "output" é a camada de estatística criada
        output.setName('ESTATISTICA OS')  # Definimos o nome da camada de estatística
        QgsProject.instance().addMapLayer(output)

        print("Valores do campo 'SELECAO' trocados para os pontos selecionados.")
        # Exibir mensagem de sucesso em uma caixa de diálogo
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Informação")
        msg_box.setText("Inversão concluída")
        msg_box.exec_()

        
        
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING gerar_etapa"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = gerar_etapaDockWidget()
                

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
            self.dockwidget.pushButton_IMPORTA_TRJ.clicked.connect(self.gpx_shp_TRJ)
            self.dockwidget.ORGANIZAR_EXCEL.clicked.connect(self.selecionar_arquivos_concatenar)
            self.dockwidget.IMPORTAR_ETAPA.clicked.connect(self.gpx_shp_solo_feito)
            self.dockwidget.SELECAO_PONTOS.clicked.connect(self.selecionar_pontos)
            self.dockwidget.pushButton_INVERTER_COLETA.clicked.connect(self.inverter_coletados)